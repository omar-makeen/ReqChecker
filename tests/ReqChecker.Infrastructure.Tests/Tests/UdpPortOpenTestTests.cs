using ReqChecker.Core.Enums;
using ReqChecker.Core.Execution;
using ReqChecker.Core.Models;
using ReqChecker.Infrastructure.Tests;
using System.Text.Json.Nodes;

namespace ReqChecker.Infrastructure.Tests.Tests;

/// <summary>
/// Unit tests for UdpPortOpenTest including parameter validation, DNS resolution, and timeout handling.
/// Note: Actual UDP socket tests require network access and are marked as integration tests.
/// </summary>
public class UdpPortOpenTestTests
{
    private readonly UdpPortOpenTest _test = new();

    #region Parameter Validation Tests

    [Fact]
    public async Task ExecuteAsync_MissingHost_ReturnsConfigurationError()
    {
        // Arrange
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = null,
            ["port"] = 53
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert
        Assert.Equal(TestStatus.Fail, result.Status);
        Assert.Equal(ErrorCategory.Configuration, result.Error?.Category);
        Assert.Contains("Host parameter is required", result.Error?.Message);
    }

    [Fact]
    public async Task ExecuteAsync_MissingPort_ReturnsConfigurationError()
    {
        // Arrange
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "8.8.8.8",
            ["port"] = null
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert
        Assert.Equal(TestStatus.Fail, result.Status);
        Assert.Equal(ErrorCategory.Configuration, result.Error?.Category);
        Assert.Contains("Port parameter is required", result.Error?.Message);
    }

    [Theory]
    [InlineData(0)]
    [InlineData(-1)]
    [InlineData(65536)]
    [InlineData(100000)]
    public async Task ExecuteAsync_InvalidPort_ReturnsConfigurationError(int invalidPort)
    {
        // Arrange
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "8.8.8.8",
            ["port"] = invalidPort
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert
        Assert.Equal(TestStatus.Fail, result.Status);
        Assert.Equal(ErrorCategory.Configuration, result.Error?.Category);
        Assert.Contains("Port must be a valid integer between 1 and 65535", result.Error?.Message);
    }

    [Fact]
    public async Task ExecuteAsync_InvalidTimeout_ReturnsConfigurationError()
    {
        // Arrange
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "8.8.8.8",
            ["port"] = 53,
            ["timeout"] = 0
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert
        Assert.Equal(TestStatus.Fail, result.Status);
        Assert.Equal(ErrorCategory.Configuration, result.Error?.Category);
        Assert.Contains("Timeout must be a positive integer", result.Error?.Message);
    }

    #endregion

    #region Valid Port Range Tests

    [Theory]
    [InlineData(1)]
    [InlineData(53)]
    [InlineData(123)]
    [InlineData(161)]
    [InlineData(65535)]
    public async Task ExecuteAsync_ValidPort_AcceptsPort(int validPort)
    {
        // Arrange - Use localhost which should fail fast
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "127.0.0.1",
            ["port"] = validPort,
            ["timeout"] = 50 // Very short timeout for fast test
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert - Should fail (timeout or network) but NOT configuration error
        Assert.Equal(TestStatus.Fail, result.Status);
        Assert.NotEqual(ErrorCategory.Configuration, result.Error?.Category);
    }

    #endregion

    #region Timeout Tests

    [Fact]
    public async Task ExecuteAsync_UnreachableHost_ReturnsTimeoutOrNetworkError()
    {
        // Arrange - Use a non-routable IP address (TEST-NET-1)
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "127.0.0.1", // Localhost - no UDP listener on port 53 typically
            ["port"] = 59999, // High port unlikely to have listener
            ["timeout"] = 100
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert - Should fail (timeout or ICMP port unreachable)
        Assert.Equal(TestStatus.Fail, result.Status);
        Assert.True(result.Error?.Category == ErrorCategory.Timeout || 
                    result.Error?.Category == ErrorCategory.Network);
    }

    [Fact]
    public async Task ExecuteAsync_Timeout_RespectsConfiguredTimeout()
    {
        // Arrange
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "127.0.0.1",
            ["port"] = 59998,
            ["timeout"] = 200
        });

        var stopwatch = System.Diagnostics.Stopwatch.StartNew();

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        stopwatch.Stop();

        // Assert - Should timeout around 200ms, not default 5000ms
        Assert.True(stopwatch.ElapsedMilliseconds < 1000, 
            $"Expected timeout around 200ms, but took {stopwatch.ElapsedMilliseconds}ms");
        Assert.Equal(TestStatus.Fail, result.Status);
    }

    #endregion

    #region DNS Resolution Tests

    [Fact]
    public async Task ExecuteAsync_InvalidHostname_ReturnsNetworkError()
    {
        // Arrange - Use an invalid hostname that won't resolve
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "this-host-definitely-does-not-exist-12345.invalid",
            ["port"] = 53,
            ["timeout"] = 1000
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert
        Assert.Equal(TestStatus.Fail, result.Status);
        Assert.Equal(ErrorCategory.Network, result.Error?.Category);
    }

    [Fact]
    public async Task ExecuteAsync_IpAddressAsHost_AcceptsDirectly()
    {
        // Arrange - Use localhost IP (no DNS resolution needed)
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "127.0.0.1",
            ["port"] = 59997,
            ["timeout"] = 100
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert - Should fail (timeout or network) but NOT DNS error
        Assert.Equal(TestStatus.Fail, result.Status);
        // If it was a configuration error, the IP parsing failed
        Assert.NotEqual(ErrorCategory.Configuration, result.Error?.Category);
    }

    [Fact]
    public async Task ExecuteAsync_IPv6Address_AcceptsDirectly()
    {
        // Arrange - Use IPv6 localhost (no DNS resolution needed)
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "::1", // IPv6 localhost
            ["port"] = 59987,
            ["timeout"] = 100
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert - Should fail (timeout or network) but NOT configuration error
        Assert.Equal(TestStatus.Fail, result.Status);
        Assert.NotEqual(ErrorCategory.Configuration, result.Error?.Category);
    }

    #endregion

    #region Cancellation Tests

    [Fact]
    public async Task ExecuteAsync_Cancellation_ReturnsSkipped()
    {
        // Arrange
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "8.8.8.8",
            ["port"] = 53,
            ["timeout"] = 5000
        });

        var cts = new CancellationTokenSource();
        cts.Cancel();

        // Act
        var result = await _test.ExecuteAsync(definition, null, cts.Token);

        // Assert
        Assert.Equal(TestStatus.Skipped, result.Status);
        Assert.Equal(ErrorCategory.Unknown, result.Error?.Category);
        Assert.Contains("cancelled", result.HumanSummary.ToLowerInvariant());
    }

    #endregion

    #region Result Properties Tests

    [Fact]
    public async Task ExecuteAsync_SetsBasicResultProperties()
    {
        // Arrange
        var definition = CreateTestDefinition("test-udp-001", "UDP Test", parameters: new Dictionary<string, object?>
        {
            ["host"] = "127.0.0.1",
            ["port"] = 59996,
            ["timeout"] = 100
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert
        Assert.Equal("test-udp-001", result.TestId);
        Assert.Equal("UdpPortOpen", result.TestType);
        Assert.Equal("UDP Test", result.DisplayName);
        Assert.NotEqual(DateTimeOffset.MinValue, result.StartTime);
        Assert.NotEqual(DateTimeOffset.MinValue, result.EndTime);
        Assert.True(result.Duration >= TimeSpan.Zero);
    }

    [Fact]
    public async Task ExecuteAsync_Failure_IncludesHumanReadableSummary()
    {
        // Arrange
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "127.0.0.1",
            ["port"] = 59995,
            ["timeout"] = 100
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert
        Assert.False(string.IsNullOrEmpty(result.HumanSummary));
        Assert.False(string.IsNullOrEmpty(result.TechnicalDetails));
    }

    #endregion

    #region Payload Encoding Tests (User Story 2)

    [Fact]
    public async Task ExecuteAsync_InvalidHex_ReturnsConfigurationError()
    {
        // Arrange - Invalid hex string (odd length)
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "127.0.0.1",
            ["port"] = 59991,
            ["timeout"] = 100,
            ["payload"] = "48656c6c6", // Odd length - invalid hex
            ["encoding"] = "hex"
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert
        Assert.Equal(TestStatus.Fail, result.Status);
        Assert.Equal(ErrorCategory.Configuration, result.Error?.Category);
    }

    [Fact]
    public async Task ExecuteAsync_UnknownEncoding_ReturnsConfigurationError()
    {
        // Arrange
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "127.0.0.1",
            ["port"] = 59989,
            ["timeout"] = 100,
            ["payload"] = "test",
            ["encoding"] = "unknown"
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert
        Assert.Equal(TestStatus.Fail, result.Status);
        Assert.Equal(ErrorCategory.Configuration, result.Error?.Category);
        Assert.Contains("Unknown encoding", result.Error?.Message);
    }

    #endregion

    #region Integration Tests (Require Network - Marked as Fact but may skip in CI)

    [Fact(Skip = "Integration test - requires network access to Google DNS")]
    public async Task ExecuteAsync_GoogleDns_ReturnsPass()
    {
        // Arrange
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "8.8.8.8",
            ["port"] = 53,
            ["timeout"] = 5000
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert
        Assert.Equal(TestStatus.Pass, result.Status);
        Assert.NotNull(result.Evidence);
        Assert.False(string.IsNullOrEmpty(result.Evidence.ResponseData));
    }

    [Fact(Skip = "Integration test - requires network access")]
    public async Task ExecuteAsync_GoogleDnsHostname_ResolvesAndReturnsPass()
    {
        // Arrange
        var definition = CreateTestDefinition("test-001", parameters: new Dictionary<string, object?>
        {
            ["host"] = "dns.google",
            ["port"] = 53,
            ["timeout"] = 5000
        });

        // Act
        var result = await _test.ExecuteAsync(definition, null, CancellationToken.None);

        // Assert
        Assert.Equal(TestStatus.Pass, result.Status);
    }

    #endregion

    #region Helper Methods

    private static TestDefinition CreateTestDefinition(
        string id,
        string displayName = "Test",
        Dictionary<string, object?>? parameters = null)
    {
        var jsonParameters = new System.Text.Json.Nodes.JsonObject();
        if (parameters != null)
        {
            foreach (var kvp in parameters)
            {
                if (kvp.Value == null)
                {
                    jsonParameters[kvp.Key] = null;
                }
                else
                {
                    jsonParameters[kvp.Key] = System.Text.Json.Nodes.JsonValue.Create(kvp.Value);
                }
            }
        }

        return new TestDefinition
        {
            Id = id,
            Type = "UdpPortOpen",
            DisplayName = displayName,
            Parameters = jsonParameters,
            DependsOn = new List<string>()
        };
    }

    #endregion
}
