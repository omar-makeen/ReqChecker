using ReqChecker.Core.Execution;
using ReqChecker.Core.Interfaces;
using ReqChecker.Core.Models;
using ReqChecker.Core.Enums;
using System.Diagnostics;
using System.Net.Sockets;

namespace ReqChecker.Infrastructure.Tests;

/// <summary>
/// Tests TCP port connectivity by attempting to establish a TCP connection to a host:port.
/// </summary>
[TestType("TcpPortOpen")]
public class TcpPortOpenTest : ITest
{
    /// <inheritdoc/>
    public async Task<TestResult> ExecuteAsync(TestDefinition testDefinition, TestExecutionContext? context, CancellationToken cancellationToken = default)
    {
        var result = new TestResult
        {
            TestId = testDefinition.Id,
            TestType = testDefinition.Type,
            DisplayName = testDefinition.DisplayName,
            Status = TestStatus.Fail, // Default to fail, will update on success
            StartTime = DateTime.UtcNow
        };

        var stopwatch = Stopwatch.StartNew();

        try
        {
            // Get parameters
            var host = testDefinition.Parameters["host"]?.ToString() ?? string.Empty;
            var portValue = testDefinition.Parameters["port"];
            var connectTimeoutValue = testDefinition.Parameters["connectTimeout"];

            // Validate required parameters
            if (string.IsNullOrEmpty(host))
            {
                throw new ArgumentException("Host parameter is required", nameof(host));
            }

            if (portValue == null)
            {
                throw new ArgumentException("Port parameter is required", "port");
            }

            if (!int.TryParse(portValue.ToString(), out int port) || port < 1 || port > 65535)
            {
                throw new ArgumentException("Port must be a valid integer between 1 and 65535", "port");
            }

            // Get connect timeout (default 5000ms)
            int connectTimeout = 5000;
            if (connectTimeoutValue != null && int.TryParse(connectTimeoutValue.ToString(), out int timeout))
            {
                connectTimeout = timeout;
            }

            cancellationToken.ThrowIfCancellationRequested();

            // Create a linked cancellation token source for timeout
            using var timeoutCts = new CancellationTokenSource(connectTimeout);
            using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);

            // Attempt to connect
            string? remoteEndpoint = null;
            bool connected = false;

            try
            {
                using var tcpClient = new TcpClient();
                await tcpClient.ConnectAsync(host, port, linkedCts.Token);

                stopwatch.Stop();
                result.EndTime = DateTime.UtcNow;
                result.Duration = stopwatch.Elapsed;

                connected = true;
                remoteEndpoint = tcpClient.Client.RemoteEndPoint?.ToString() ?? $"{host}:{port}";

                result.Status = TestStatus.Pass;
            }
            catch (SocketException ex) when (ex.SocketErrorCode == SocketError.ConnectionRefused)
            {
                stopwatch.Stop();
                result.EndTime = DateTime.UtcNow;
                result.Duration = stopwatch.Elapsed;

                connected = false;
                result.Status = TestStatus.Fail;
                result.Error = new TestError
                {
                    Category = ErrorCategory.Network,
                    Message = $"Connection to {host}:{port} was refused",
                    StackTrace = ex.StackTrace
                };
            }
            catch (SocketException ex) when (ex.SocketErrorCode == SocketError.TimedOut)
            {
                stopwatch.Stop();
                result.EndTime = DateTime.UtcNow;
                result.Duration = stopwatch.Elapsed;

                connected = false;
                result.Status = TestStatus.Fail;
                result.Error = new TestError
                {
                    Category = ErrorCategory.Timeout,
                    Message = $"Connection to {host}:{port} timed out",
                    StackTrace = ex.StackTrace
                };
            }
            catch (SocketException ex) when (ex.SocketErrorCode == SocketError.HostUnreachable ||
                                             ex.SocketErrorCode == SocketError.HostNotFound)
            {
                stopwatch.Stop();
                result.EndTime = DateTime.UtcNow;
                result.Duration = stopwatch.Elapsed;

                connected = false;
                result.Status = TestStatus.Fail;
                result.Error = new TestError
                {
                    Category = ErrorCategory.Network,
                    Message = $"Host '{host}' is unreachable or not found",
                    StackTrace = ex.StackTrace
                };
            }

            // Build evidence
            var evidence = new Dictionary<string, object>
            {
                ["host"] = host,
                ["port"] = port,
                ["connected"] = connected,
                ["connectTimeMs"] = stopwatch.ElapsedMilliseconds
            };

            if (remoteEndpoint != null)
            {
                evidence["remoteEndpoint"] = remoteEndpoint;
            }

            result.Evidence = new TestEvidence
            {
                ResponseData = System.Text.Json.JsonSerializer.Serialize(evidence),
                Timing = new TimingBreakdown
                {
                    TotalMs = (int)stopwatch.ElapsedMilliseconds,
                    ConnectMs = (int)stopwatch.ElapsedMilliseconds
                }
            };
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
            stopwatch.Stop();
            result.EndTime = DateTime.UtcNow;
            result.Duration = stopwatch.Elapsed;
            result.Status = TestStatus.Skipped;
            result.Error = new TestError
            {
                Category = ErrorCategory.Unknown,
                Message = "Test was cancelled"
            };
        }
        catch (OperationCanceledException)
        {
            // Timeout occurred
            stopwatch.Stop();
            result.EndTime = DateTime.UtcNow;
            result.Duration = stopwatch.Elapsed;
            result.Status = TestStatus.Fail;
            result.Error = new TestError
            {
                Category = ErrorCategory.Timeout,
                Message = "Connection timed out",
            };
        }
        catch (ArgumentException ex)
        {
            stopwatch.Stop();
            result.EndTime = DateTime.UtcNow;
            result.Duration = stopwatch.Elapsed;
            result.Status = TestStatus.Fail;
            result.Error = new TestError
            {
                Category = ErrorCategory.Configuration,
                Message = ex.Message,
                StackTrace = ex.StackTrace
            };
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            result.EndTime = DateTime.UtcNow;
            result.Duration = stopwatch.Elapsed;
            result.Status = TestStatus.Fail;
            result.Error = new TestError
            {
                Category = ErrorCategory.Network,
                Message = ex.Message,
                StackTrace = ex.StackTrace
            };
        }

        return result;
    }
}
