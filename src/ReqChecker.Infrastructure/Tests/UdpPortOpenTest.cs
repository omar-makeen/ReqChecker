using ReqChecker.Core.Execution;
using ReqChecker.Core.Interfaces;
using ReqChecker.Core.Models;
using ReqChecker.Core.Enums;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.Json;

namespace ReqChecker.Infrastructure.Tests;

/// <summary>
/// Evidence captured during UDP port test execution.
/// </summary>
public class UdpPortTestEvidence
{
    /// <summary>
    /// Indicates whether a UDP response was received.
    /// </summary>
    public bool Responded { get; set; }

    /// <summary>
    /// Round-trip time in milliseconds (from send to receive).
    /// Null if no response received.
    /// </summary>
    public int? RoundTripTimeMs { get; set; }

    /// <summary>
    /// Remote endpoint in "IP:Port" format (e.g., "8.8.8.8:53").
    /// </summary>
    public string? RemoteEndpoint { get; set; }

    /// <summary>
    /// Size of the sent UDP datagram in bytes.
    /// </summary>
    public int PayloadSentBytes { get; set; }

    /// <summary>
    /// Size of the received UDP datagram in bytes.
    /// Null if no response received.
    /// </summary>
    public int? PayloadReceivedBytes { get; set; }

    /// <summary>
    /// First 64 bytes of response data as hex string (for debugging).
    /// Null if no response received.
    /// </summary>
    public string? ResponseDataPreview { get; set; }
}

/// <summary>
/// Tests UDP port reachability by sending a datagram and waiting for a response.
/// Supports custom payloads (hex/base64 encoded) and optional response pattern validation.
/// </summary>
[TestType("UdpPortOpen")]
public class UdpPortOpenTest : ITest
{
    private const int DefaultTimeoutMs = 5000;
    private const int MaxResponsePreviewBytes = 64;

    /// <inheritdoc/>
    public async Task<TestResult> ExecuteAsync(TestDefinition testDefinition, TestExecutionContext? context, CancellationToken cancellationToken = default)
    {
        var result = new TestResult
        {
            TestId = testDefinition.Id,
            TestType = testDefinition.Type,
            DisplayName = testDefinition.DisplayName,
            Status = TestStatus.Fail,
            StartTime = DateTime.UtcNow
        };

        var stopwatch = Stopwatch.StartNew();
        UdpTestParameters? parameters = null;

        try
        {
            // Extract and validate parameters
            parameters = ExtractParameters(testDefinition);
            cancellationToken.ThrowIfCancellationRequested();

            // Resolve hostname to IP address
            var ipAddress = await ResolveHostAsync(parameters.Host, cancellationToken);
            cancellationToken.ThrowIfCancellationRequested();

            // Execute UDP test
            var endpoint = new IPEndPoint(ipAddress, parameters.Port);
            var (responded, receivedBytes, remoteEndpoint) = await ExecuteUdpTestAsync(
                endpoint,
                parameters.Payload,
                parameters.Timeout,
                cancellationToken);

            stopwatch.Stop();
            result.EndTime = DateTime.UtcNow;
            result.Duration = stopwatch.Elapsed;

            // Build result based on response
            if (responded)
            {
                result = BuildSuccessResult(result, parameters, receivedBytes!, remoteEndpoint!, stopwatch.ElapsedMilliseconds);
            }
            else
            {
                result = BuildTimeoutResult(result, parameters, stopwatch.ElapsedMilliseconds);
            }
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
            stopwatch.Stop();
            result.EndTime = DateTime.UtcNow;
            result.Duration = stopwatch.Elapsed;
            result = BuildCancelledResult(result, stopwatch.Elapsed);
        }
        catch (ArgumentException ex)
        {
            stopwatch.Stop();
            result.EndTime = DateTime.UtcNow;
            result.Duration = stopwatch.Elapsed;
            result = BuildErrorResult(result, ex, ErrorCategory.Configuration, stopwatch.Elapsed, parameters);
        }
        catch (SocketException ex) when (ex.SocketErrorCode == SocketError.ConnectionReset)
        {
            stopwatch.Stop();
            result.EndTime = DateTime.UtcNow;
            result.Duration = stopwatch.Elapsed;
            result = BuildIcmpErrorResult(result, ex, stopwatch.Elapsed, parameters);
        }
        catch (SocketException ex)
        {
            stopwatch.Stop();
            result.EndTime = DateTime.UtcNow;
            result.Duration = stopwatch.Elapsed;
            result = BuildErrorResult(result, ex, ErrorCategory.Network, stopwatch.Elapsed, parameters);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            result.EndTime = DateTime.UtcNow;
            result.Duration = stopwatch.Elapsed;
            result = BuildErrorResult(result, ex, ErrorCategory.Network, stopwatch.Elapsed, parameters);
        }

        return result;
    }

    #region Parameter Extraction

    /// <summary>
    /// Extracts and validates parameters from the test definition.
    /// </summary>
    private UdpTestParameters ExtractParameters(TestDefinition testDefinition)
    {
        var parameters = testDefinition.Parameters;

        // Host (required)
        var host = parameters["host"]?.ToString();
        if (string.IsNullOrWhiteSpace(host))
        {
            throw new ArgumentException("Host parameter is required and cannot be empty", "host");
        }

        // Port (required)
        var portValue = parameters["port"];
        if (portValue == null)
        {
            throw new ArgumentException("Port parameter is required", "port");
        }
        if (!int.TryParse(portValue.ToString(), out int port) || port < 1 || port > 65535)
        {
            throw new ArgumentException("Port must be a valid integer between 1 and 65535", "port");
        }

        // Timeout (optional, default 5000ms)
        int timeout = DefaultTimeoutMs;
        var timeoutValue = parameters["timeout"];
        if (timeoutValue != null && int.TryParse(timeoutValue.ToString(), out int parsedTimeout))
        {
            if (parsedTimeout <= 0)
            {
                throw new ArgumentException("Timeout must be a positive integer", "timeout");
            }
            timeout = parsedTimeout;
        }

        // Payload (optional, default single null byte)
        byte[] payload = new byte[] { 0x00 };
        var payloadValue = parameters["payload"]?.ToString();
        if (!string.IsNullOrEmpty(payloadValue))
        {
            var encoding = parameters["encoding"]?.ToString() ?? "auto";
            payload = DecodePayload(payloadValue, encoding);
        }

        // Expected response (optional)
        byte[]? expectedResponse = null;
        var expectedResponseValue = parameters["expectedResponse"]?.ToString();
        if (!string.IsNullOrEmpty(expectedResponseValue))
        {
            var encoding = parameters["encoding"]?.ToString() ?? "auto";
            expectedResponse = DecodePayload(expectedResponseValue, encoding);
        }

        return new UdpTestParameters
        {
            Host = host,
            Port = port,
            Timeout = timeout,
            Payload = payload,
            ExpectedResponse = expectedResponse
        };
    }

    /// <summary>
    /// Internal container for extracted test parameters.
    /// </summary>
    private class UdpTestParameters
    {
        public string Host { get; set; } = string.Empty;
        public int Port { get; set; }
        public int Timeout { get; set; }
        public byte[] Payload { get; set; } = Array.Empty<byte>();
        public byte[]? ExpectedResponse { get; set; }
    }

    #endregion

    #region DNS Resolution

    /// <summary>
    /// Resolves a hostname to an IP address, preferring IPv4 for compatibility.
    /// </summary>
    private async Task<IPAddress> ResolveHostAsync(string host, CancellationToken cancellationToken)
    {
        // Try to parse as IP address first
        if (IPAddress.TryParse(host, out var parsedIp))
        {
            return parsedIp;
        }

        // Resolve via DNS
        try
        {
            var addresses = await Dns.GetHostAddressesAsync(host, cancellationToken);
            if (addresses == null || addresses.Length == 0)
            {
                throw new SocketException((int)SocketError.HostNotFound);
            }

            // Prefer IPv4 for broad compatibility
            var ipv4 = addresses.FirstOrDefault(a => a.AddressFamily == AddressFamily.InterNetwork);
            if (ipv4 != null)
            {
                return ipv4;
            }

            // Fall back to IPv6 if no IPv4 available
            var ipv6 = addresses.FirstOrDefault(a => a.AddressFamily == AddressFamily.InterNetworkV6);
            if (ipv6 != null)
            {
                return ipv6;
            }

            throw new SocketException((int)SocketError.HostNotFound);
        }
        catch (SocketException)
        {
            throw;
        }
        catch (Exception ex)
        {
            throw new SocketException((int)SocketError.HostNotFound)
            {
                Source = $"DNS resolution failed for '{host}': {ex.Message}"
            };
        }
    }

    #endregion

    #region UDP Test Execution

    /// <summary>
    /// Executes the UDP send/receive operation with timeout handling.
    /// </summary>
    private async Task<(bool responded, byte[]? receivedBytes, IPEndPoint? remoteEndpoint)> ExecuteUdpTestAsync(
        IPEndPoint endpoint,
        byte[] payload,
        int timeout,
        CancellationToken cancellationToken)
    {
        using var udpClient = new UdpClient(endpoint.AddressFamily);
        udpClient.Client.ReceiveTimeout = timeout;

        // Send the datagram
        await udpClient.SendAsync(payload, payload.Length, endpoint);

        // Wait for response with timeout using Task.WhenAny pattern
        using var timeoutCts = new CancellationTokenSource(timeout);
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);

        try
        {
            // Use CancellationToken overload to properly cancel receive on timeout
            // This avoids the Task.WhenAny pattern which leaves receiveTask running after disposal
            var result = await udpClient.ReceiveAsync(linkedCts.Token);
            return (true, result.Buffer, result.RemoteEndPoint);
        }
        catch (SocketException ex) when (ex.SocketErrorCode == SocketError.ConnectionReset)
        {
            // ICMP Port Unreachable received - rethrow for specific handling
            throw;
        }
        catch (OperationCanceledException)
        {
            // Timeout or user cancellation occurred
            return (false, null, null);
        }
    }

    #endregion

    #region Payload Encoding (User Story 2)

    /// <summary>
    /// Decodes a payload string using the specified encoding (hex, base64, utf8, or auto-detect).
    /// </summary>
    private byte[] DecodePayload(string payload, string encoding)
    {
        return encoding.ToLowerInvariant() switch
        {
            "hex" => DecodeHex(payload),
            "base64" => DecodeBase64(payload),
            "utf8" => Encoding.UTF8.GetBytes(payload),
            "auto" => TryDecodeAuto(payload),
            _ => throw new ArgumentException($"Unknown encoding: {encoding}. Supported: hex, base64, utf8, auto", "encoding")
        };
    }

    /// <summary>
    /// Decodes a hex-encoded string to bytes.
    /// </summary>
    private static byte[] DecodeHex(string hex)
    {
        // Remove any spaces or common prefixes
        hex = hex.Replace(" ", "").Replace("0x", "").Replace("-", "");

        if (hex.Length % 2 != 0)
        {
            throw new ArgumentException("Hex string must have an even number of characters", nameof(hex));
        }

        if (!hex.All(c => "0123456789ABCDEFabcdef".Contains(c)))
        {
            throw new ArgumentException("Hex string contains invalid characters", nameof(hex));
        }

        return Convert.FromHexString(hex);
    }

    /// <summary>
    /// Decodes a base64-encoded string to bytes.
    /// </summary>
    private static byte[] DecodeBase64(string base64)
    {
        try
        {
            return Convert.FromBase64String(base64);
        }
        catch (FormatException)
        {
            throw new ArgumentException("Invalid base64 string", nameof(base64));
        }
    }

    /// <summary>
    /// Auto-detects encoding and decodes the payload.
    /// Heuristic: hex if even length and all hex chars, else try base64, else UTF-8.
    /// </summary>
    private static byte[] TryDecodeAuto(string payload)
    {
        // Check if it looks like hex (even length, all hex chars)
        var cleanedHex = payload.Replace(" ", "").Replace("0x", "").Replace("-", "");
        if (cleanedHex.Length % 2 == 0 && cleanedHex.Length > 0 && cleanedHex.All(c => "0123456789ABCDEFabcdef".Contains(c)))
        {
            try
            {
                return Convert.FromHexString(cleanedHex);
            }
            catch
            {
                // Fall through to base64 check
            }
        }

        // Check if it looks like base64
        try
        {
            // Base64 strings are typically multiples of 4 chars with padding
            if (payload.Length >= 4 && (payload.Length % 4 == 0 || payload.Contains('=')))
            {
                return Convert.FromBase64String(payload);
            }
        }
        catch
        {
            // Fall through to UTF-8
        }

        // Default to UTF-8
        return Encoding.UTF8.GetBytes(payload);
    }

    #endregion

    #region Response Validation (User Story 2)

    /// <summary>
    /// Validates the received response against the expected pattern.
    /// Performs an exact byte-for-byte match as specified in FR-008.
    /// </summary>
    private bool ValidateResponse(byte[] received, byte[] expected)
    {
        if (expected == null || expected.Length == 0)
        {
            return true; // No validation required
        }

        if (received == null || received.Length != expected.Length)
        {
            return false;
        }

        // Check if the response exactly matches the expected pattern (FR-008)
        return received.AsSpan().SequenceEqual(expected);
    }

    /// <summary>
    /// Finds the first byte offset where two arrays differ.
    /// </summary>
    private static int FindMismatchOffset(byte[] received, byte[] expected)
    {
        int minLength = Math.Min(received.Length, expected.Length);
        for (int i = 0; i < minLength; i++)
        {
            if (received[i] != expected[i])
            {
                return i;
            }
        }
        return minLength;
    }

    #endregion

    #region Result Building

    /// <summary>
    /// Builds a successful test result with evidence.
    /// </summary>
    private TestResult BuildSuccessResult(TestResult result, UdpTestParameters parameters, byte[] receivedBytes, IPEndPoint remoteEndpoint, long elapsedMs)
    {
        // Validate response if expected pattern provided
        if (parameters.ExpectedResponse != null && !ValidateResponse(receivedBytes, parameters.ExpectedResponse))
        {
            return BuildValidationFailResult(result, parameters, receivedBytes, elapsedMs);
        }

        var evidence = new UdpPortTestEvidence
        {
            Responded = true,
            RoundTripTimeMs = (int)elapsedMs,
            RemoteEndpoint = remoteEndpoint.ToString(),
            PayloadSentBytes = parameters.Payload.Length,
            PayloadReceivedBytes = receivedBytes.Length,
            ResponseDataPreview = Convert.ToHexString(receivedBytes.Take(MaxResponsePreviewBytes).ToArray()).ToLowerInvariant()
        };

        result.Status = TestStatus.Pass;
        result.HumanSummary = $"UDP port {parameters.Port} on {parameters.Host} responded in {elapsedMs} ms (sent {parameters.Payload.Length} bytes, received {receivedBytes.Length} bytes)";
        result.TechnicalDetails = $"Sent {parameters.Payload.Length}-byte datagram to {remoteEndpoint}\n" +
                                  $"Received {receivedBytes.Length}-byte response in {elapsedMs} ms\n" +
                                  $"Response (hex): {evidence.ResponseDataPreview}{(receivedBytes.Length > MaxResponsePreviewBytes ? "..." : "")}";
        result.Evidence = new TestEvidence
        {
            ResponseData = JsonSerializer.Serialize(evidence),
            Timing = new TimingBreakdown
            {
                TotalMs = (int)elapsedMs
            }
        };

        return result;
    }

    /// <summary>
    /// Builds a validation failure result when response doesn't match expected pattern.
    /// </summary>
    private TestResult BuildValidationFailResult(TestResult result, UdpTestParameters parameters, byte[] receivedBytes, long elapsedMs)
    {
        var mismatchOffset = FindMismatchOffset(receivedBytes, parameters.ExpectedResponse!);
        var expectedPreview = Convert.ToHexString(parameters.ExpectedResponse!.Take(MaxResponsePreviewBytes).ToArray()).ToLowerInvariant();
        var actualPreview = Convert.ToHexString(receivedBytes.Take(MaxResponsePreviewBytes).ToArray()).ToLowerInvariant();

        var evidence = new UdpPortTestEvidence
        {
            Responded = true,
            RoundTripTimeMs = (int)elapsedMs,
            RemoteEndpoint = $"{parameters.Host}:{parameters.Port}",
            PayloadSentBytes = parameters.Payload.Length,
            PayloadReceivedBytes = receivedBytes.Length,
            ResponseDataPreview = actualPreview
        };

        result.Status = TestStatus.Fail;
        result.Error = new TestError
        {
            Category = ErrorCategory.Validation,
            Message = $"Response did not match expected pattern (mismatch at byte offset {mismatchOffset})"
        };
        result.HumanSummary = $"UDP port {parameters.Port} on {parameters.Host} responded but data did not match expected pattern (received {receivedBytes.Length} bytes)";
        result.TechnicalDetails = $"Expected response pattern ({parameters.ExpectedResponse!.Length} bytes): {expectedPreview}...\n" +
                                  $"Actual response ({receivedBytes.Length} bytes): {actualPreview}...\n" +
                                  $"Mismatch at byte offset {mismatchOffset}";
        result.Evidence = new TestEvidence
        {
            ResponseData = JsonSerializer.Serialize(evidence),
            Timing = new TimingBreakdown
            {
                TotalMs = (int)elapsedMs
            }
        };

        return result;
    }

    /// <summary>
    /// Builds a timeout result when no response is received.
    /// </summary>
    private TestResult BuildTimeoutResult(TestResult result, UdpTestParameters parameters, long elapsedMs)
    {
        var evidence = new UdpPortTestEvidence
        {
            Responded = false,
            RoundTripTimeMs = null,
            RemoteEndpoint = $"{parameters.Host}:{parameters.Port}",
            PayloadSentBytes = parameters.Payload.Length,
            PayloadReceivedBytes = null,
            ResponseDataPreview = null
        };

        result.Status = TestStatus.Fail;
        result.Error = new TestError
        {
            Category = ErrorCategory.Timeout,
            Message = $"No response received within {parameters.Timeout} ms"
        };
        result.HumanSummary = $"UDP port {parameters.Port} on {parameters.Host} did not respond within {parameters.Timeout} ms";
        result.TechnicalDetails = $"Sent {parameters.Payload.Length}-byte datagram to {parameters.Host}:{parameters.Port}\n" +
                                  $"No response received within {parameters.Timeout} ms timeout\n" +
                                  $"Possible causes: service not running, firewall blocking, incorrect port";
        result.Evidence = new TestEvidence
        {
            ResponseData = JsonSerializer.Serialize(evidence),
            Timing = new TimingBreakdown
            {
                TotalMs = (int)elapsedMs
            }
        };

        return result;
    }

    /// <summary>
    /// Builds a cancelled result when the test is cancelled by user.
    /// </summary>
    private TestResult BuildCancelledResult(TestResult result, TimeSpan elapsed)
    {
        result.Status = TestStatus.Skipped;
        result.Error = new TestError
        {
            Category = ErrorCategory.Unknown,
            Message = "Test was cancelled"
        };
        result.HumanSummary = "Test was cancelled by user";
        result.TechnicalDetails = "Test execution was cancelled before completion";

        return result;
    }

    /// <summary>
    /// Builds an ICMP Port Unreachable error result.
    /// </summary>
    private TestResult BuildIcmpErrorResult(TestResult result, SocketException ex, TimeSpan elapsed, UdpTestParameters? parameters)
    {
        var endpointInfo = parameters != null
            ? $"{parameters.Host}:{parameters.Port}"
            : "unknown endpoint";

        var evidence = new UdpPortTestEvidence
        {
            Responded = false,
            RoundTripTimeMs = null,
            RemoteEndpoint = endpointInfo,
            PayloadSentBytes = parameters?.Payload.Length ?? 0,
            PayloadReceivedBytes = null,
            ResponseDataPreview = null
        };

        result.Status = TestStatus.Fail;
        result.Error = new TestError
        {
            Category = ErrorCategory.Network,
            Message = "ICMP Port Unreachable received",
            StackTrace = ex.StackTrace
        };
        result.HumanSummary = parameters != null
            ? $"UDP port {parameters.Port} on {parameters.Host} is unreachable (ICMP Port Unreachable received)"
            : "UDP port is unreachable (ICMP Port Unreachable received)";
        result.TechnicalDetails = $"ICMP Destination Unreachable (Port Unreachable) received for {endpointInfo}\n" +
                                  $"Host is reachable but port has no listener";
        result.Evidence = new TestEvidence
        {
            ResponseData = JsonSerializer.Serialize(evidence),
            Timing = new TimingBreakdown
            {
                TotalMs = (int)elapsed.TotalMilliseconds
            }
        };

        return result;
    }

    /// <summary>
    /// Builds a generic error result.
    /// </summary>
    private TestResult BuildErrorResult(TestResult result, Exception ex, ErrorCategory category, TimeSpan elapsed, UdpTestParameters? parameters)
    {
        var endpointInfo = parameters != null
            ? $"{parameters.Host}:{parameters.Port}"
            : null;

        result.Status = TestStatus.Fail;
        result.Error = new TestError
        {
            Category = category,
            Message = ex.Message,
            StackTrace = ex.StackTrace
        };
        result.HumanSummary = category switch
        {
            ErrorCategory.Configuration => $"Configuration error: {ex.Message}",
            ErrorCategory.Network => parameters != null
                ? $"Network error for {parameters.Host}:{parameters.Port}: {ex.Message}"
                : $"Network error: {ex.Message}",
            _ => $"Error: {ex.Message}"
        };
        result.TechnicalDetails = $"Error: {ex.Message}\n" +
                                  $"Type: {ex.GetType().Name}\n" +
                                  (endpointInfo != null ? $"Endpoint: {endpointInfo}\n" : "") +
                                  (ex.InnerException != null ? $"Inner: {ex.InnerException.Message}\n" : "") +
                                  $"Stack: {ex.StackTrace}";

        return result;
    }

    #endregion
}
